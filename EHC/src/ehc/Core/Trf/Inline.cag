%%[93 hs module {%{EH}Core.Trf.Inline} import ({%{EH}Ty},{%{EH}Base.Common},{%{EH}LamInfo},{%{EH}Core},{%{EH}AbstractCore}, {%{EH}Core.Trf.Subst} (apply), {%{EH}Core.Trf.Rewrite}(ConvMp(..)), qualified Data.Map as Map, Debug.Trace(trace), Data.Maybe(fromJust,isJust,isNothing), Control.Monad(when), {%{EH}Core.Trf.CaseOfKnown}(caseOfKnown))
%%]

%%[93 ag import ({Core/AbsSyn})

-- CURRENTLY BROKEN FOR TYPECLASSES

{ 
inline :: FuncMp -> ConvMp -> CExpr -> CExpr
inline funcMp convMp expr = 
        let t = wrap_CExpr (sem_CExpr expr)
                           (Inh_CExpr { funcMp_Inh_CExpr = funcMp 
                                      , convMp_Inh_CExpr = convMp
                                      }
                           )
        in inlined_Syn_CExpr t

caseOfCase :: CExpr -> CAltL -> CExpr -> CAltL -> CExpr -> CExpr
caseOfCase e outerAlts outerDflt innerAlts innerDflt = acoreCaseDflt e (pushCases outerAlts outerDflt innerAlts) (Just $ acoreCaseDflt innerDflt outerAlts (Just outerDflt))  
   where
     pushCases :: CAltL -> CExpr -> CAltL -> CAltL
     pushCases outer dflt inner = map (\ (CAlt_Alt p r) -> CAlt_Alt p (acoreCaseDflt r outer (Just dflt))) inner
}

{

type FuncMp = Map.Map HsName CExpr

}
    
WRAPPER CExpr

ATTR AllCodeNT [ funcMp : FuncMp convMp : ConvMp | | inlined : SELF ]

SEM CExpr
        | Let body.funcMp = if @categ == acoreBindcategRec 
                            then @lhs.funcMp `Map.difference` @binds.gathFuncMp
                            else @binds.gathFuncMp `Map.union` @lhs.funcMp
        | Let binds.funcMp = @lhs.funcMp


ATTR CBindL [ | | gathFuncMp USE {`Map.union`} {Map.empty} : FuncMp ]

ATTR CBind [ | | gathFuncMp : FuncMp ]

ATTR CBindAspectL [ || gathExpr USE {++} {[]} : {[CExpr]} ] -- this should just be always be a singleton list, but probably not the safest way...

ATTR CBindAspect [ || gathExpr USE {++} {[]} : {[CExpr]}]

SEM CBindAspect
        | Bind lhs.gathExpr = [@expr.inlined] 

SEM CBind 
        | Bind lhs.gathFuncMp = if not (isNothing (Map.lookup @nm @lhs.convMp))
                                then {-trace ("Not adding function " ++ show @nm ++ "because it was a conversion function") $-} Map.empty 
                                else {-trace ("Adding function " ++ show @nm ++ "to the funcMp") $-} Map.singleton @nm $ head @bindAspects.gathExpr
   

SEM CExpr 
        | App lhs.inlined = if @func.isInlinable 
                            then {- trace ("Inlining " ++ show @func.inlined) $ -} inline @lhs.funcMp @lhs.convMp $ (apply @func.inlined @arg.inlined) -- application may have triggered new opportunies, hence the recursive call.
                            else acoreApp1 @func.inlined @arg.inlined
        | Var lhs.inlined = if @isInlinable
                            then fromJust (Map.lookup (acbrefNm @ref) @lhs.funcMp)
                            else @inlined
	| Case lhs.inlined = maybe (acoreCaseDflt @expr.inlined @alts.inlined (Just @dflt.inlined)) (inline @lhs.funcMp @lhs.convMp) (orElse @loc.coc @loc.cok)

SEM CExpr
	| Case loc.cok = trace "Looking to apply CoK" $ 
                           (do { scrutineeExpr <- @loc.scrutineeExpr
                               ; trace ("CoK: Found scrutinee: " ++ show scrutineeExpr) $ return ()
                               ; constExpr   <- return scrutineeExpr
			       ; trace ("CoK: Found constructor expression: " ++ show constExpr) $ return () 
                               ; ctag        <- getConstructor constExpr
			       ; trace ("CoK: Found constructor: " ++ show constExpr) $ return ()
                               ; let cargs   = reverse (getArgs constExpr)
                               ; let alts    = @alts.altPairs
                               ; cok <- trace "CoK: Calling CoK" $ caseOfKnown ctag cargs alts
                               ; let cok' = foldr (\ (cat,bind) e -> acoreLetBase cat bind e) cok @loc.scrutineeLets
                               ; return cok'
                               })
        | Case loc.coc = trace "Looking to apply CoC" $ 
			   do { scrutineeExpr         <- @loc.scrutineeExpr -- the thing being scrutinised
                              ; e                     <- getCaseExpr scrutineeExpr  -- is it another case? If so, return the scrutinee
                              ; (innerAlts,innerDflt) <- getCaseAlts scrutineeExpr -- then get the alts and the default
                              ; let coc = foldr (\ (categ,binds) expr -> acoreLetBase categ binds expr) (trace "Case statement found in scrutinee, calling CoC" $ caseOfCase e @alts.inlined @dflt.inlined innerAlts innerDflt) @loc.scrutineeLets
                              ; trace ("CoC result: " ++ show coc) $return coc
                              }
SEM CExpr
       | Ann lhs.inlined = trace "Removing an annotation" $ @expr.inlined

SEM CExpr 
       | Case loc.scrutinee = orElse (do { scrutineeNm <- @expr.varName 
                                         ; case Map.lookup scrutineeNm @lhs.funcMp of { Nothing -> trace "No case scrutinee found in funcMp" Nothing; Just x -> trace ("Found scrutinee " ++ show x) (Just x) } } ) (Just @expr.inlined)
       | Case loc.scrutineeLets = maybe [] getLets @loc.scrutinee
       | Case loc.scrutineeExpr = @loc.scrutinee >>= (return . getLetExpr)

{
orElse :: Maybe a -> Maybe a -> Maybe a
orElse x y = case x of
		Just _  -> x
		Nothing -> y

getLets :: CExpr -> [(CBindCateg,CBindL)]
getLets (CExpr_Let categ binds expr) = (categ, binds) : getLets expr
getLets _                            = []

getLetExpr :: CExpr -> CExpr
getLetExpr (CExpr_Let _ _ expr) = getLetExpr expr
getLetExpr expr                 = expr 

isCase :: CExpr -> Bool
isCase (CExpr_Case _ _ _)  = True
isCase (CExpr_Let _ _ expr) = isCase expr

getCaseExpr :: CExpr -> Maybe CExpr
getCaseExpr (CExpr_Case expr _ _) = Just expr
getCaseExpr _                     = Nothing

getLetCaseExpr (CExpr_Let _ _ expr)  = getLetCaseExpr expr
getLetCaseExpr (CExpr_Case expr _ _) = expr

getCaseAlts :: CExpr -> Maybe (CAltL, CExpr)
getCaseAlts (CExpr_Case _ alts dflt) = Just (alts,dflt)
getCaseAlts _                        = Nothing

-- getConstructorExpr :: CExpr -> Maybe CExpr
-- getConstructorExpr (CExpr_Ann _ expr) = getConstructorExpr expr
-- getConstructorExpr expr	              = Just expr


getConstructor :: CExpr -> Maybe CTag
getConstructor (CExpr_App func arg)       = getConstructor func
getConstructor (CExpr_Tup tag)            = Just tag
getConstructor _                          = Nothing 

getArgs :: CExpr -> [CExpr] 
getArgs (CExpr_App func arg) = arg : getArgs func
getArgs _                    = []
}


ATTR AllCodeNT [ | | self : SELF ]

ATTR CAlt [ | | altPair : {(CPat,CExpr)} ]

SEM CAlt
        | Alt lhs.altPair = (@pat.self, @expr.inlined)


ATTR CAltL [ | | altPairs : {[(CPat, CExpr)]} ]

SEM CAltL
        | Cons lhs.altPairs = @hd.altPair : @tl.altPairs
        | Nil  lhs.altPairs = []  
                                
ATTR CExpr [ | | isInlinable : Bool ]

SEM CExpr
        | Var loc.isInlinable = isJust (Map.lookup (acbrefNm @ref) @lhs.funcMp)
        | Var lhs.isInlinable = @isInlinable
        | App lhs.isInlinable = @func.isInlinable
        | Lam lhs.isInlinable = True
        | * - App Var Lam lhs.isInlinable = False  

ATTR CExpr [ | | varName : {Maybe HsName} ] 

SEM CExpr
        | Var loc.varName     = Just $ acbrefNm @ref
        | Var lhs.varName     = @varName
        | * - Var lhs.varName = Nothing

%%]
