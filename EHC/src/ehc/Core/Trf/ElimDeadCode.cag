%%[93 hs module {%{EH}Core.Trf.ElimDeadCode} import ({%{EH}Base.Common},{%{EH}Core},{%{EH}Ty}, qualified Data.Set as Set, Data.Set(Set(..)))
%%]


%%[93 ag import ({Core/AbsSyn})

{
cmodTrfElimDeadCode :: CModule -> CModule
cmodTrfElimDeadCode cmod = 
        let t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                               (Inh_CodeAGItf {})
        in trf_Syn_CodeAGItf t
}

WRAPPER CodeAGItf 

ATTR AllCodeNT [ | | varS USE {`Set.union`} {Set.empty} : {Set HsName} ]

SEM CExpr
        | Var lhs.varS = Set.singleton $ acbrefNm @ref
	| Let lhs.varS = if @loc.removable 
                         then @body.varS 
                         else (@binds.varS `Set.union` @body.varS) `Set.difference` Set.fromList @binds.nms

ATTR CodeAGItf [ | | trf : CModule]
ATTR AllCodeNT [ | | trf : SELF]

SEM CExpr 
	| Let loc.removable = not $ Set.fold (\ a b -> a `elem` @binds.nms || b) False @body.varS

SEM CExpr
        | Let lhs.trf = if @loc.removable 
                        then @body.trf
                        else @trf

ATTR CBind [ | | nm : {HsName} ]

SEM CBind 
        | Bind lhs.nm = @nm

ATTR CBindL [ | | nms : {[HsName]} ]

SEM CBindL
        | Cons lhs.nms = @hd.nm : @tl.nms
        | Nil  lhs.nms = [] 
%%]
