%%[93 hs module {%{EH}Core.Trf.LetCaseScrutinee} import ({%{EH}Base.Common}, {%{EH}Ty}) export (cmodTrfLetCaseScrutinee)
%%]

%%[93 hs import (Debug.Trace, Data.Set(Set(..)), qualified Data.Set as Set, Data.Maybe(fromMaybe))
%%]

%%[93 hs import({%{EH}AbstractCore},{%{EH}Core})
%%]

%%[93 ag import ({Core/AbsSyn})
{
cmodTrfLetCaseScrutinee :: HsName -> UID -> CModule -> CModule
cmodTrfLetCaseScrutinee modNm uniq cmod
  = let t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                           (Inh_CodeAGItf { gUniq_Inh_CodeAGItf = uniq
                                          , modNm_Inh_CodeAGItf = modNm
                                          })
    in cTrf_Syn_CodeAGItf t
}

 
WRAPPER CodeAGItf

ATTR AllCodeNT CodeAGItf [ modNm: HsName | | ]

ATTR AllCodeNT [ | gUniq: UID | ]
ATTR CodeAGItf [ gUniq: UID | | ]

SEM CExpr
  | App         (func.gUniq,loc.lUniq)      =   mkNewUID @lhs.gUniq
  | Lam         (body.gUniq,loc.lUniq,loc.lUniq2)
                                            =   mkNewLevUID2 @lhs.gUniq
  | Let         (binds.gUniq,loc.lUniq)     =   mkNewUID @lhs.gUniq
  | Case TupDel TupIns TupUpd
                (expr.gUniq,loc.lUniq)      =   mkNewUID @lhs.gUniq

ATTR AllCodeNT [ sBindS : {Set HsName} | | ]

SEM CodeAGItf
  | AGItf module.sBindS = Set.empty

SEM CExpr
  | Let body.sBindS = if @categ == acoreBindcategStrict
                      then foldr Set.insert @lhs.sBindS @binds.nmL
		      else @lhs.sBindS

ATTR CBindL [ | | nmL : {[HsName]} ]

SEM CBindL
  | Cons lhs.nmL = @hd.nm : @tl.nmL
  | Nil lhs.nmL  = []

ATTR CBind [ | | nm : HsName ]

SEM CBind
  | Bind lhs.nm = @nm

ATTR AllCodeNT [ | | cTrf : SELF ]
ATTR CodeAGItf [ | | cTrf : CModule]
 
SEM CExpr
  | Case lhs.cTrf = fromMaybe (trace ("Found non-strictly bound scrutinee" ++ show @expr.cTrf) $ acoreLet acoreBindcategStrict [(acoreBind1 @trNm @expr.cTrf)] (acoreCaseDflt (acoreVar @trNm) @alts.cTrf (Just @dflt.cTrf)))
                      (do { nm <- @expr.varName 
                          ; if Set.member nm @lhs.sBindS 
			    then return $ trace "Found strictly bound scrutinee, nbd" $ acoreCaseDflt @expr.cTrf @alts.cTrf (Just @dflt.cTrf)
			    else Nothing})  

SEM CExpr
  | Case loc.trNm = hsnQualUniqify @lhs.modNm $ uidHNm @lUniq

ATTR CExpr [ | | varName : {Maybe HsName} ]

SEM CExpr
  | Var lhs.varName     = Just $ acbrefNm @ref
  | * - Var lhs.varName = Nothing
%%]
