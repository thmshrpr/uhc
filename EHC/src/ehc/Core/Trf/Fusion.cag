%%[93 hs module {%{EH}Core.Trf.Fusion} import ({%{EH}Core.Trf.Rewrite} (rewrite, ConvMp(..), Role(..)), {%{EH}Core.Trf.Inline} (inline, FuncMp(..))) 
%%]

%%[93 hs import (qualified Data.Set as Set,Data.Maybe (fromMaybe, isJust, isNothing),Debug.Trace,{%{EH}Ty},{%{EH}Base.Common},{%{EH}LamInfo},{%{EH}Core},{%{EH}AbstractCore}, {%{EH}Core.Trf.Subst} (apply),  qualified Data.Map as Map)
%%]

%%[93 ag import ({Core/AbsSyn})

{
cmodTrfFusion :: LamMp -> CModule -> CModule
cmodTrfFusion lamMp cmod = 
     let t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod)) 
                            (Inh_CodeAGItf {lamMp_Inh_CodeAGItf = lamMp
                                           } )
     in inlined_Syn_CodeAGItf t
}

-- PRAGMA nocycle

-- Main idea: inlined should inline all fusible functions (and their non-recursive subterms)
--            rewritten should take the result and do forall x. cons (abs x) |-> x
--            fused should finish the job

-- applied should find fusible functions in a pipeline, inline them, and try to find the conversion functions

ATTR CodeAGItf [ || applied : CModule]
ATTR AllCodeNT [ || applied : SELF]

SEM CExpr
        | App lhs.applied = @applied
        | App loc.applied = if @func.isFusible
                            then trace "Applying..." $ apply @func.applied @arg.applied
                            else acoreApp1 @func.applied @arg.applied
        | Var lhs.applied = if @isFusible 
                            then fromMaybe @applied (Map.lookup (acbrefNm @ref) @lhs.fuseMp)
                            else @applied


ATTR CodeAGItf [ | | rewritten : CModule]
ATTR AllCodeNT [ | | rewritten : SELF]
 
SEM CExpr 
       | App lhs.rewritten = @loc.rewritten
       | App loc.rewritten = if @func.isFusible && @arg.isFusible 
                             then trace "Rewriting..." $ rewrite @lhs.convMp @loc.applied 
                             else acoreApp1 @func.rewritten @arg.rewritten

--Fuse all the things.  Any fusible function should be fair game, regardless of whether it is applied to a fusible one or not.  We are no longer looking for rewrite rules, so conversion functions inlined, too, if they remain

ATTR CodeAGItf [ | | inlined : CModule]
ATTR AllCodeNT [ | | inlined : SELF   ]
 
SEM CExpr 
       | App lhs.inlined = if @func.isFusible
                           then trace ("Calling inline with funcMp " ++ (show $ Map.keys @lhs.funcMp)) $ inline @lhs.funcMp @lhs.convMp @loc.rewritten 
                           else acoreApp1 @func.inlined @arg.inlined

------------------------------------------------------------------------------
-- Tests to see if a function is fusible.  A @func of an App is fusible if it 
-- is a named function found in the fuseMp, if it is a function application 
-- whose @func is fusible. 
------------------------------------------------------------------------------

ATTR CExpr [ | | isFusible : Bool ]

SEM CExpr
        | Var loc.isFusible           = isJust (Map.lookup (acbrefNm @ref) @lhs.fuseMp)
        | Var lhs.isFusible           = @isFusible
        | App lhs.isFusible           = @func.isFusible
	| Ann lhs.isFusible           = @expr.isFusible
        | Let lhs.isFusible           = @body.isFusible
        | * - App Var Ann Let lhs.isFusible   = False

-- Transformations to actually perform a beta reduction. An App node is beta reduced by calling 
-- subst nm body expr, where nm is the variable to replace, body is the body of the function, and 
-- expr is the expr to substitute in for nm that passes in the substExpr attribute.

------------------------------------------------------------------------------
-- Gather the names of conversions and their role into a Map 
------------------------------------------------------------------------------

ATTR AllCodeNT [ convMp : ConvMp | | ]

SEM CodeAGItf
        | AGItf module.convMp = Map.empty

SEM CExpr
        | Let body.convMp = @binds.gathConvMp `Map.union` @lhs.convMp

ATTR CBindL [ | | gathConvMp USE {`Map.union`} {Map.empty} : ConvMp ]

ATTR CBind  [ | | gathConvMp : ConvMp ]

SEM CBind
        | Bind loc.gathConvMp = fromMaybe Map.empty (do 
                                    { lamInfo <- Map.lookup @nm @lhs.lamMp   
                                    ; role    <- Map.lookup acbaspkeyFusionRole (laminfoBindAspMp lamInfo) 
                                    ; return (case role of
                                                 LamInfoBindAsp_FusionRole FusionRole_BuildLeft  -> Map.singleton @nm Abs 
                                                 LamInfoBindAsp_FusionRole FusionRole_BuildRight -> Map.singleton @nm Con 
                                                 _                                               -> Map.empty)
                                    })
                                        
------------------------------------------------------------------------------
-- Pass fusible function names and bodies down the expressions
------------------------------------------------------------------------------

WRAPPER CodeAGItf 

{
type FuncS  = Set.Set HsName
}

ATTR CodeAGItf AllCodeNT [lamMp : LamMp  | | ] -- passed in, contains which functions have which fusion roles
ATTR AllCodeNT [fuseMp : FuncMp | | ] -- starts blank, this will contain the transformed code (circular dependecy) for the functions that need to be inlined for fusion 

SEM CodeAGItf
        | AGItf module.fuseMp = Map.empty


SEM CExpr
        | Let body.fuseMp  = @binds.gathFuseMp `Map.union` @lhs.fuseMp -- gather the functions from let bindings that need to be fused, and add them to the parent's fusion map, and push this down the tree


ATTR CBindL [ || gathFuseMp USE {`Map.union`} {Map.empty} : FuncMp ] -- combine all the maps for all the elements of a CBind list

ATTR CBind [ || gathFuseMp : FuncMp ]

SEM CBind 
  | Bind loc.gathFuseMp = fromMaybe Map.empty (do 
                            { lamInfo <- Map.lookup @nm @lhs.lamMp -- look up a bindings lamInfo 
                            ; role    <- Map.lookup acbaspkeyFusionRole (laminfoBindAspMp lamInfo) 
                            ; return (case role of
                                        LamInfoBindAsp_FusionRole FusionRole_Fuse -> Map.singleton @nm $ head @bindAspects.gathExpr -- add the name + expression 
                                        _                                         -> Map.empty)
                            })

ATTR CBindAspectL [ || gathExpr USE {++} {[]} : {[CExpr]} ] -- this should just be always be a singleton list, but probably not the safest way...

ATTR CBindAspect [ || gathExpr USE {++} {[]} : {[CExpr]}]

SEM CBindAspect
        | Bind lhs.gathExpr = [@expr.inlined] 


-------------------------------------------------------------------------------
-- Collect the names of fusible transformers (that is, functions that are used 
-- in fusible functions that aren't conversion functions)
-------------------------------------------------------------------------------

ATTR AllCodeNT [ inFusibleFunc : Bool | | ]

SEM CodeAGItf
        | AGItf module.inFusibleFunc = False
 

SEM CBind
        | Bind bindAspects.inFusibleFunc = @lhs.inFusibleFunc || isJust (Map.lookup @nm @gathFuseMp) 
                                               

ATTR AllCodeNT [ funcMp : FuncMp | | ]

SEM CodeAGItf
        | AGItf module.funcMp = Map.empty
{-
ATTR CodeAGItf AllCodeNT [ | | funcS USE {`Set.union`} {Set.empty} : FuncS ]


SEM CExpr
        | Var lhs.funcS = if @lhs.inFusibleFunc
                          then trace ("Adding function " ++ show (acbrefNm @ref) ++ " to the funcS") $ Set.singleton (acbrefNm @ref)
                          else Set.empty 
-}
SEM CExpr 
        | Let body.funcMp = if @categ == acoreBindcategRec 
                            then @lhs.funcMp `Map.difference` @binds.gathFuncMp 
                            else @binds.gathFuncMp `Map.union` @lhs.funcMp
        | Let binds.funcMp = @lhs.funcMp    

ATTR CBindL [ | | gathFuncMp USE {`Map.union`} {Map.empty} : FuncMp ]

ATTR CBind [ | | gathFuncMp : FuncMp ]

SEM CBind 
        | Bind lhs.gathFuncMp = if not (isNothing (Map.lookup @nm @lhs.convMp))
                                then trace ("Not adding function " ++ show @nm ++ "because it was a conversion function") $ Map.empty          
                                else trace ("Adding function " ++ show @nm ++ "to the funcMp") $ Map.singleton @nm $ head @bindAspects.gathExpr

ATTR CExpr [ | | varName : {Maybe HsName} ] 

SEM CExpr
        | Var lhs.varName     = Just $ acbrefNm @ref
        | * - Var lhs.varName = Nothing
%%] 
